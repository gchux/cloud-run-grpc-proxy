package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"regexp"
	"strings"
	"sync"
	"text/template"

	mapset "github.com/deckarep/golang-set/v2"
)

var (
	codegenSrc = flag.String("codegen_src", "", "")
	codegenDst = flag.String("codegen_dst", "", "")
)

const (
	googleCloudGoBasePackage = "cloud.google.com/go/"

	tmpl = `// Code generated by grpc-proxy/proto/cmd/codegen.go; DO NOT EDIT.

package proxy

import (
	"reflect"

	"github.com/zhangyunhao116/skipmap"

{{- range $alias, $import := .imports }}
	{{$alias}} "{{$import -}}"
{{- end }}
)
	
	var method2RequestType *skipmap.OrderedMap[string, reflect.Type]
	var method2ResponseType *skipmap.OrderedMap[string, reflect.Type]

func init() {
	method2RequestType = skipmap.New[string, reflect.Type]()
	method2ResponseType = skipmap.New[string, reflect.Type]()

{{- range $method, $request := .rpcReq }}
	method2RequestType.Store("{{$method}}", reflect.TypeOf((*{{ index $.rpcReqGoPkg $method }}.{{$request}})(nil)).Elem())
	method2ResponseType.Store("{{$method}}", reflect.TypeOf((*{{ index $.rpcResGoPkg $method }}.{{ index $.rpcRes $method }})(nil)).Elem())
{{- end }}
}
`
)

// GeneratedCodeRegexp checks the code generation standard
// defined at https://golang.org/s/generatedcode.
var GeneratedCodeRegexp = regexp.MustCompile(`(?m:^// Code generated .* DO NOT EDIT\.$)`)

// CreateFile runs the "text/template".Template with data, pass it through gofmt
// and saves it to filePath.
func CreateFile(filePath string, t *template.Template, data interface{}) (err error) {
	return (&CodeTemplate{Template: t}).CreateFile(filePath, data)
}

// CodeTemplate is the precompiled template for generating one or multiple Go source files.
type CodeTemplate struct {
	Template *template.Template // See "text/template"
	Buffer   bytes.Buffer       // Used for sharing allocated memory between multiple CreateFile calls
	mu       sync.Mutex
}

// Parse creates a CodeTemplate from a "text/template" source.
//
// The expansion of the template is expected to be valid a Go source file
// containing the code generation standard tag. See GeneratedCodeRegexp.
func Parse(codeTemplate string) (*CodeTemplate, error) {
	t, err := template.New("").Parse(codeTemplate)
	if err != nil {
		return nil, err
	}
	return &CodeTemplate{Template: t}, nil
}

// MustParse wraps Parse throwing errors as exception.
func MustParse(codeTemplate string) *CodeTemplate {
	tmpl, err := Parse(codeTemplate)
	if err != nil {
		panic(err)
	}
	return tmpl
}

// CreateFile runs the template with data, pass it through gofmt
// and saves it to filePath.
//
// The code generation standard at https://golang.org/s/generatedcode is enforced.
func (t *CodeTemplate) CreateFile(filePath string, data interface{}) error {
	// This anonymous function exists just to wrap the mutex protected block
	out, err := func() ([]byte, error) {
		// To protect t.Buffer
		t.mu.Lock()
		defer t.mu.Unlock()

		t.Buffer.Reset()

		if err := t.Template.Execute(&t.Buffer, data); err != nil {
			return nil, err
		}

		code := t.Buffer.Bytes()

		// Enforce code generation standard https://golang.org/s/generatedcode
		if !GeneratedCodeRegexp.Match(code) {
			return nil, errors.New("output does not follow standard defined at https://golang.org/s/generatedcode")
		}

		// return format.Source(code)
		return code, nil
	}()
	if err != nil {
		return err
	}

	f, err := os.Create(filePath)
	if err == nil {
		defer f.Close()
		_, err = f.Write(out)
	}
	return err
}

// method2Type.Store("{{$method}}:{{$request}}", reflect.TypeOf((*{{ index $.rpcGoPkg $method }}.{{$request}})(nil)).Elem())
// method2Type.Store("$method.$request", reflect.TypeOf({{index .rpcPkg "$method"}}.$request))
// 	method2Type.Store("$method.{{.index .rpcRes "$method"}}", reflect.TypeOf({{index .rpcPkg "$method"}}.{{.index .rpcRes "$method"}}))

func main_codegen() {
	jsonFile, err := openJSON(codegenSrc)
	if err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(1)
	}

	jsonFileBytes, err := io.ReadAll(jsonFile)
	if err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(2)
	}

	protoDefs := make([]ProtoDef, 0)
	json.Unmarshal(jsonFileBytes, &protoDefs)

	// [ToDo]: use NAMESPACES, TYPES and IMPORTS from json

	namespaces := mapset.NewSet[string]()
	namespaces.Add("emptypb")
	namespaces.Add("httpbodypb")
	namespaces.Add("metricpb")
	namespaces.Add("monitoredrespb")
	namespaces.Add("serviceconfigpb")
	namespaces.Add("longrunningpb")
	namespaces.Add("oslogin_common_commonpb")

	imports := make(map[string]string)
	imports["emptypb"] = "google.golang.org/protobuf/types/known/emptypb"
	imports["httpbodypb"] = "google.golang.org/genproto/googleapis/api/httpbody"
	imports["metricpb"] = "google.golang.org/genproto/googleapis/api/metric"
	imports["monitoredrespb"] = "google.golang.org/genproto/googleapis/api/monitoredres"
	imports["serviceconfigpb"] = "google.golang.org/genproto/googleapis/api/serviceconfig"
	imports["longrunningpb"] = "cloud.google.com/go/longrunning/autogen/longrunningpb"
	imports["oslogin_common_commonpb"] = "cloud.google.com/go/oslogin/common/commonpb"

	messageType2namespace := make(map[string]string)
	// https://github.com/googleapis/google-cloud-go/blob/main/internal/gapicgen/generator/genproto.go#L56-L140
	messageType2namespace["google.api.HttpBody"] = "httpbodypb"
	messageType2namespace["google.api.Service"] = "serviceconfigpb"
	messageType2namespace["google.api.MetricDescriptor"] = "metricpb"
	messageType2namespace["google.api.MonitoredResourceDescriptor"] = "monitoredrespb"
	messageType2namespace["google.protobuf.Empty"] = "emptypb"
	messageType2namespace["google.longrunning.Operation"] = "longrunningpb"
	messageType2namespace["google.cloud.oslogin.common.SshPublicKey"] = "oslogin_common_commonpb"

	for _, protoDef := range protoDefs {
		for _, rpc := range protoDef.RPCs {
			namespaces.Add(*protoDef.Go.Namespace)

			requestType := *rpc.Request.Type
			responseType := *rpc.Response.Type

			if !strings.HasPrefix(requestType, "google.") {
				messageType2namespace[*protoDef.Package+"."+requestType] = *protoDef.Go.Namespace
			} else if strings.HasPrefix(requestType, *protoDef.Package) {
				messageType2namespace[requestType] = *protoDef.Go.Namespace
			}

			if !strings.HasPrefix(responseType, "google.") {
				messageType2namespace[*protoDef.Package+"."+responseType] = *protoDef.Go.Namespace
			} else if strings.HasPrefix(responseType, *protoDef.Package) {
				messageType2namespace[responseType] = *protoDef.Go.Namespace
			}
		}
	}

	rpcMethod2rpcReq := make(map[string]string)
	rpcMethod2rpcRes := make(map[string]string)
	rpcMethod2rpcReqGoPkg := make(map[string]string)
	rpcMethod2rpcResGoPkg := make(map[string]string)

	blacklist := mapset.NewSet[string]()
	blacklist.Add("StreamRawPredictRequest")
	blacklist.Add("UpdateDeploymentResourcePoolRequest")

	whitelist := mapset.NewSet[string]()

	usedNamespaces := mapset.NewSet[string]()

	for _, protoDef := range protoDefs {
		if !whitelist.IsEmpty() &&
			!whitelist.Contains(*protoDef.Package) {
			continue
		}

		goPkgFull := *protoDef.Go.PackageFull
		goPkgFullParts := goPkgRegexp.FindStringSubmatch(goPkgFull)
		if len(goPkgFullParts) == 0 {
			continue
		}
		goPkgAlias := *protoDef.Go.Namespace

		imports[goPkgAlias] = goPkgFull

		for _, svc := range protoDef.Services {
			pkgAndSvc := *protoDef.Package + "." + *svc
			for _, rpc := range protoDef.RPCs {
				requestType := *rpc.Request.Type
				responseType := *rpc.Response.Type

				if blacklist.ContainsAny(requestType, responseType) {
					continue
				}

				fullMethodName := pkgAndSvc + "/" + *rpc.Method

				if strings.HasPrefix(requestType, "google.") {
					requestTypeParts := strings.Split(requestType, ".")
					rpcMethod2rpcReq[fullMethodName] = requestTypeParts[len(requestTypeParts)-1]
					rpcMethod2rpcReqGoPkg[fullMethodName] = messageType2namespace[requestType]
					usedNamespaces.Add(messageType2namespace[requestType])
				} else {
					rpcMethod2rpcReq[fullMethodName] = requestType
					rpcMethod2rpcReqGoPkg[fullMethodName] = goPkgAlias
					usedNamespaces.Add(goPkgAlias)
				}

				if strings.HasPrefix(responseType, "google.") {
					responseTypeParts := strings.Split(responseType, ".")
					rpcMethod2rpcRes[fullMethodName] = responseTypeParts[len(responseTypeParts)-1]
					rpcMethod2rpcResGoPkg[fullMethodName] = messageType2namespace[responseType]
					usedNamespaces.Add(messageType2namespace[responseType])
				} else {
					rpcMethod2rpcRes[fullMethodName] = *rpc.Response.Type
					rpcMethod2rpcResGoPkg[fullMethodName] = goPkgAlias
					usedNamespaces.Add(goPkgAlias)
				}
			}
		}
	}

	namespaces.Difference(usedNamespaces).
		Each(func(namespace string) bool {
			delete(imports, namespace)
			return false
		})

	MustParse(tmpl).CreateFile(
		*codegenDst,
		map[string]any{
			"imports":     imports,
			"rpcReq":      rpcMethod2rpcReq,
			"rpcRes":      rpcMethod2rpcRes,
			"rpcReqGoPkg": rpcMethod2rpcReqGoPkg,
			"rpcResGoPkg": rpcMethod2rpcResGoPkg,
		},
	)
}
